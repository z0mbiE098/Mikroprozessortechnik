


ARM Macro Assembler    Page 1 


    1 00000000         ;*******************************************************
                       *************
    2 00000000         ;* htw saar - Fakultaet fuer Ingenieurwissenschaften    
                       *
    3 00000000         ;* Labor fuer Eingebettete Systeme         *
    4 00000000         ;* Mikroprozessortechnik           *
    5 00000000         ;*******************************************************
                       *************
    6 00000000         ;* Assembler_Startup.S:            *
    7 00000000         ;* Programmrumpf fuer Assembler-Programme mit dem Keil  
                         *
    8 00000000         ;* Entwicklungsprogramm uVision fuer ARM-Mikrocontroller
                          *
    9 00000000         ;*******************************************************
                       *************
   10 00000000         ;* Aufgabe-Nr.:          *  Verusch 1                 *
   11 00000000         ;*                 *             *
   12 00000000         ;*******************************************************
                       *************
   13 00000000         ;* Gruppen-Nr.:    * 1. Gruppe am Freitag ab 3. Stunde *
                       
   14 00000000         ;*                 *          *
   15 00000000         ;*******************************************************
                       *************
   16 00000000         ;* Name / Matrikel-Nr.:  * Hanan Ahmed Ashir, 5012967   
                       *
   17 00000000         ;*       * Erwin Holzhauser, 5013983    *
   18 00000000         ;*       *          *
   19 00000000         ;*******************************************************
                       *************
   20 00000000         ;* Abgabedatum:          *  19.12.2025                *
   21 00000000         ;*       *          *
   22 00000000         ;*******************************************************
                       *************
   23 00000000         
   24 00000000         ;*******************************************************
                       *************
   25 00000000         ;* Daten-Bereich bzw. Daten-Speicher                 *
   26 00000000         ;*******************************************************
                       *************
   27 00000000                 AREA             Daten, DATA, READWRITE ;Ezeugun
                                                            g einer Speicherber
                                                            eich fï¿½r Daten(RA
                                                            M)       
   28 00000000         Datenanfang
   29 00000000         
   30 00000000         
   31 00000000 00000000 
                       X       EQU              Datenanfang ; in memory -> ASCI
                                                            I 0x40000000
   32 00000000 00000400 
                       Top_Stack
                               EQU              Datenanfang + RAM_Size
   33 00000000 00000400 
                       Datenende
                               EQU              Top_Stack
   34 00000000         
   35 00000000         ;*******************************************************
                       *************



ARM Macro Assembler    Page 2 


   36 00000000         ;* Programm-Bereich bzw. Programm-Speicher       *
   37 00000000         ;*******************************************************
                       *************
   38 00000000         
   39 00000000                 AREA             Programm, CODE, READONLY
   40 00000000                 ARM
   41 00000000 E321F010 
                       Reset_Handler
                               MSR              CPSR_c, #0x10 ; MSR=Move to Sta
                                                            tus Register. Der U
                                                            ser Mode wird in CP
                                                            SR geschrieben
   42 00000004         
   43 00000004 31 30 00 
                       String  DCB              "10",0
   44 00000007 00              ALIGN                        ; Falls die Adresse
                                                             nicht durch 4 teil
                                                            bar ist, fï¿½lle si
                                                            e mit Nullen
   45 00000008         ;*******************************************************
                       *************
   46 00000008         ;* Hier das eigene (Haupt-)Programm einfuegen        *
   47 00000008         ;*******************************************************
                       *************
   48 00000008 E59FD0E4        LDR              SP, =Top_Stack ;Stack-pointer s
                                                            tartet hier
   49 0000000C E59F00E4        LDR              R0, =X      ; Load Register: Di
                                                            e Adresse von volls
                                                            tï¿½ndiges 32 Bit W
                                                            ort wird geladen
   50 00000010 EB000031        BL               Berechnung  ; 
   51 00000014         
   52 00000014         ;LDR R0, =String
   53 00000014         ;BL AtoI
   54 00000014         
   55 00000014         ;LDR R0, =X
   56 00000014         ;LDR R0, [R0]
   57 00000014         ;BL Formel
   58 00000014         
   59 00000014         ;LDR R0, =Number
   60 00000014         ;LDR R0, [R0]
   61 00000014         ;BL uItoBCD
   62 00000014         ;*******************************************************
                       *************
   63 00000014         ;* Ende des eigenen (Haupt-)Programms                   
                                   *
   64 00000014         ;*******************************************************
                       *************
   65 00000014         
   66 00000014 EAFFFFFE 
                       endlos  B                endlos      ;
   67 00000018         
   68 00000018         ;*******************************************************
                       *************
   69 00000018         ;* ab hier Unterprogramme                               
                                   *
   70 00000018         ;*******************************************************
                       *************
   71 00000018         



ARM Macro Assembler    Page 3 


   72 00000018         
   73 00000018         ;------------------------Aufgabe 1----------------------
                       -------------
   74 00000018         AtoI
   75 00000018 E92D403E        STMFD            SP!, {R1-R5, LR}
   76 0000001C E3A02000        MOV              R2, #0      ; Hier wird das Erg
                                                            ebnis gespeichert
   77 00000020 E3A05000        MOV              R5, #0      ; Hier kommt der St
                                                            atus Flag
   78 00000024         
   79 00000024 E5D01000        LDRB             R1, [R0]    ; Das erste Zeichen
                                                             von der Eingabe wi
                                                            rd geprï¿½ft
   80 00000028 E351002D        CMP              R1, #0x2D   ; CMP macht intern 
                                                            eine Subtraktion: R
                                                            1 = R1-0x2D und set
                                                            zt die Flags im CSP
                                                            R
   81 0000002C 01A05001        MOVEQ            R5, R1      ;
   82 00000030 02800001        ADDEQ            R0, R0, #1  ; Setze Flag in R5.
                                                             Move if Z-Flag=1
   83 00000034         
   84 00000034 E351002B        CMP              R1, #0x2B   ; Auch eine Subtrak
                                                            tion: R1 = R1-0x2B 
                                                            und die Flags in CS
                                                            PR werden gesetzt
   85 00000038 02800001        ADDEQ            R0, R0, #1  ; Wenn Zeichen + is
                                                            t und Flag gesetzt 
                                                            ist, wird ADDEQ aus
                                                            gefï¿½hrt und Point
                                                            er wird zu nï¿½chst
                                                            er Stelle inkrement
                                                            iert
   86 0000003C         
   87 0000003C         AtoI_Loop
   88 0000003C E4D01001        LDRB             R1, [R0], #1 ; Load Register By
                                                            te. Zeochen aus R0 
                                                            wird geladen und Ze
                                                            iger zeigt mit #1 d
                                                            irekt auf die nï¿½c
                                                            hste Stelle
   89 00000040 E3510000        CMP              R1, #0      ; R1=R1-0. Flags se
                                                            tzen
   90 00000044 0A000004        BEQ              AtoI_End    ; Falls Stringende 
                                                            erreicht, dann zum 
                                                            Ende springen
   91 00000048         
   92 00000048 E2411030        SUB              R1, R1, #CHAR_0 ; ASCII Zeichen
                                                             werden in numerisc
                                                            her Wert konvertier
                                                            t(z.B. 6(0x36) - 0(
                                                            0x30) = 6)
   93 0000004C         
   94 0000004C E1A04182        MOV              R4, R2, LSL #3 ; Ersten teil de
                                                            r Multiplikation.
   95 00000050         ; Die zahl die bisher in R2 steht muss auf Zehnerstelle 
                       rï¿½cken, um platz fï¿½r die nï¿½chste Zahl zu machen.
   96 00000050 E0844082        ADD              R4, R4, R2, LSL #1 ; Add nimmt 
                                                            das Ergebnis von R4



ARM Macro Assembler    Page 4 


                                                             und addiert die R2
                                                            *2 dazu.
   97 00000054         ; R4  = Die bisherige Zahl(multipliziert mit 10)
   98 00000054 E0842001        ADD              R2, R4, R1  ; Jetzt mï¿½ssen wi
                                                            r die neue Zahl bil
                                                            den. (Alte Zahl in 
                                                            R4(60) + neue Zahl 
                                                            in R1(5) = "65___"
   99 00000058 EAFFFFF7        B                AtoI_Loop   ; Zurï¿½ck zum Anfa
                                                            ng, wo es weitergeh
                                                            t
  100 0000005C         
  101 0000005C         AtoI_End
  102 0000005C E3550000        CMP              R5, #0      ; Falls im R5 eine 
                                                            negative Flag steht
                                                            .
  103 00000060 12622000        RSBNE            R2, R2, #0  ; Reverse Substract
                                                             Not Equals, 0 - R2
                                                            , falls negative Fl
                                                            ag gesetzt ist, um 
                                                            Zahl zu negieren
  104 00000064 E1A00002        MOV              R0, R2      ; Ergebnis in R0 ab
                                                            speichern
  105 00000068 E8BD403E        LDMFD            SP!, {R1-R5, LR} ; Registern wi
                                                            eder freigeben
  106 0000006C E12FFF1E        BX               LR
  107 00000070         
  108 00000070         
  109 00000070         
  110 00000070         ;-----------------Aufgabe 2 mit magic numbers-----------
                       ------------
  111 00000070         
  112 00000070         Formel
  113 00000070 E92D401E        STMFD            SP! ,{R1-R4, LR}
  114 00000074 E59F1080        LDR              R1, =DIV_9  ; R1 wird mit der M
                                                            agic Number geladen
                                                            (Siehe Skript Seite
                                                             96) 
  115 00000078 E0020090        MUL              R2, R0, R0  ; Quadrat wird bere
                                                            chnet und in R2 ges
                                                            peichert: R2 = (R0)
                                                            ^2
  116 0000007C E0843192        UMULL            R3, R4, R2, R1 ; UMULL: Unsigne
                                                            d Multiply long, we
                                                            il X^2*DIV_9 eine Z
                                                            ahl>32-Bit ist. 
  117 00000080         ; Ergebis wird eine 64-Bit Zahl, die in zwei Registern g
                       espeichert wird. (63-32)=R4, (31-0)=R3
  118 00000080 E1A030A4        MOV              R3, R4, LSR #1 ; Um die grï¿½ï¿
                                                            ½e Zahl mit genauig
                                                            keit in einem regis
                                                            ter zu schreiben ma
                                                            chen wir ein Right 
                                                            shift.(siehe "n" au
                                                            f der Siete 96)
  119 00000084         ; Also (X^2/9) wird grob geschï¿½tzt und im Register R3 
                       gespeichert.
  120 00000084 E1A00103        MOV              R0, R3, LSL #2 ; Wir rechnen hi
                                                            er (X^2/9)*4. Also 



ARM Macro Assembler    Page 5 


                                                            Link Shift um 2^2=4
                                                            .
  121 00000088 E8BD401E        LDMFD            SP!, {R1-R4, LR} ; Registern we
                                                            rden wieder vom Sta
                                                            ck entfernt und Erg
                                                            ebnis steht im R0
  122 0000008C E12FFF1E        BX               LR          ; Wieder zu Rï¿½cks
                                                            prungadressen sprin
                                                            gen
  123 00000090         
  124 00000090         ;------------------------Aufgabe 3 mit magic numbers----
                       -------------
  125 00000090         
  126 00000090         ; anhand dieses Formel (Pseudocode): while (dec)
  127 00000090         ;    {
  128 00000090         ;        result +=  (dec % 10) << shift;
  129 00000090         ;        dec = dec / 10;
  130 00000090         ;        shift += 4;
  131 00000090         ;    }
  132 00000090         ;    return result;
  133 00000090         
  134 00000090         uItoBCD
  135 00000090 E92D41FE        STMFD            SP! ,{R1-R8, LR} ; Register R1 
                                                            bis R8 auf den Stac
                                                            k laden.
  136 00000094 E3A01000        MOV              R1, #0      ; Ergebnis wird hie
                                                            r gespeichert
  137 00000098 E3A02000        MOV              R2, #0      ; Shift kommmt hier
                                                            . (0,4,8,...)
  138 0000009C E59F505C        LDR              R5, =DIV_10 ; R5 bekommt magisc
                                                            he Nummer fï¿½r Div
                                                            ision durch 10
  139 000000A0 E3A0600A        MOV              R6, #10     ; R6 bekommt die Ko
                                                            nstante Zahl 10 fï¿
                                                            ½r Modulo-Operation
                                                            
  140 000000A4         
  141 000000A4         uItoBCD_Loop
  142 000000A4 E3500000        CMP              R0, #0      ; R0 = R0-0 und Fla
                                                            gs Setzen. Falls Er
                                                            gebnis 0, dann sind
                                                             wir schon fertig
  143 000000A8 0A000008        BEQ              uItoBCD_Done ; Springe zu Ende
  144 000000AC         
  145 000000AC         
  146 000000AC E0873590        UMULL            R3, R7, R0, R5 ; Unsigned Integ
                                                            er, also UMULL darf
                                                             verwendet werden. 
                                                            
  147 000000B0         ; R0 wird mit magische Nummer multipliziert und Ergebnis
                        wird in R3 ind R7 gespeichert   
  148 000000B0 E1A031A7        MOV              R3, R7, LSR#3 ; Genauere Ergebi
                                                            s in 32 Bit, R7 mus
                                                            s noch 3 bits geshi
                                                            ftet werden(siehe "
                                                            n" Seite 96)
  149 000000B4         ; Fï¿½r 123 berechnen wir: q = 123/10 = 12(kommt in R3)
  150 000000B4         
  151 000000B4 E0040693        MUL              R4, R3, R6  ; In R4 steht jetzt



ARM Macro Assembler    Page 6 


                                                             = q * 10.  Dann is
                                                            t R4=12*10=120     
                                                                               
                                                                               
                                                                     ------ mul
                                                             lieber mit shift -
                                                            > schneller
  152 000000B8 E0404004        SUB              R4, R0, R4  ; r = R0 - (q * 10)
                                                             , sprich modulo. (
                                                            123 -120) = 3. Also
                                                             letzte Dezimalziff
                                                            er steht in R4
  153 000000BC         
  154 000000BC E1A08214        MOV              R8, R4, LSL R2 ; Nimmt den Inha
                                                            lt von n und schieb
                                                            t so viele Bits nac
                                                            h links, wie in R2 
                                                            steht              
                                                                        ------ 
                                                            kann man sich spare
                                                            n, diretk bei add s
                                                            hiften
  155 000000C0         ; Das Ergebnis landet dann in R8
  156 000000C0 E0811008        ADD              R1, R1, R8  ; R1 speichert das 
                                                            BCD Ergebnis, R8 wi
                                                            rd dort addiert.
  157 000000C4         
  158 000000C4         
  159 000000C4 E1A00003        MOV              R0, R3      ; R3 enthï¿½lt die 
                                                            Quotient, das wird 
                                                            in R0 als Eingabe g
                                                            eschickt und die nï
                                                            ¿½chste Iteration b
                                                            eginnt
  160 000000C8 E2822004        ADD              R2, R2, #4  ; bei jeder iterati
                                                            on wird einmla mehr
                                                             um 4 geshiftet, da
                                                            mit die nï¿½chste D
                                                            ezimalzahl richtig 
                                                            positioniert wird
  161 000000CC         
  162 000000CC EAFFFFF4        B                uItoBCD_Loop ; Sprint zurï¿½ck 
                                                            zum Anfang der Schl
                                                            eife
  163 000000D0         
  164 000000D0         uItoBCD_Done
  165 000000D0 E1A00001        MOV              R0, R1      ; Fertige BCD Ergni
                                                            s wird in R0 gemove
                                                            d 
  166 000000D4 E8BD41FE        LDMFD            SP! ,{R1-R8, LR} ; Registern wi
                                                            eder freimachen
  167 000000D8 E12FFF1E        BX               LR          ; Zur Rï¿½cksprunga
                                                            dresse springen
  168 000000DC         
  169 000000DC         ;------------------------Aufgabe 4----------------------
                       -------------
  170 000000DC         
  171 000000DC         Berechnung
  172 000000DC E92D4000        STMFD            SP!, {LR}   ; Rï¿½cksprungadres



ARM Macro Assembler    Page 7 


                                                            se sichern
  173 000000E0         
  174 000000E0 EBFFFFCC        BL               AtoI        ; R0 = X (signed In
                                                            teger)
  175 000000E4 EBFFFFE1        BL               Formel      ; R0 = Y = 4*X^2/9
  176 000000E8 EBFFFFE8        BL               uItoBCD     ; R0 = Y als BCD
  177 000000EC         
  178 000000EC E8BD4000        LDMFD            SP! ,{LR}
  179 000000F0 E12FFF1E        BX               LR
  180 000000F4         
  181 000000F4         
  182 000000F4         ;*******************************************************
                       *************
  183 000000F4         ;* Konstanten im CODE-Bereich                           
                                   *
  184 000000F4         ;*******************************************************
                       *************
  185 000000F4         
  186 000000F4 38E38E39 
                       DIV_9   EQU              0x38E38E39  ; mit n=1
  187 000000F4 CCCCCCCD 
                       DIV_10  EQU              0xCCCCCCCD  ; mit n=3
  188 000000F4 00000030 
                       CHAR_0  EQU              0x30
  189 000000F4 00000400 
                       RAM_Size
                               EQU              0x400       ; 4*16^2=1024 bytes
                                                            
  190 000000F4         
  191 000000F4         ;X DCD 100
  192 000000F4         ;Number DCD 3043
  193 000000F4         
  194 000000F4         
  195 000000F4         ;*******************************************************
                       *************
  196 000000F4         ;* Ende der Programm-Quelle                             
                                   *
  197 000000F4         ;*******************************************************
                       *************
  198 000000F4                 END
              00000000 
              00000000 
              38E38E39 
              CCCCCCCD 
Command Line: --debug --xref --depend=.\assembler_startup.d -o.\assembler_start
up.o -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Phili
ps --predefine="__EVAL SETA 1" --list=.\assembler_startup.lst Assembler_Startup
.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

Daten 00000000

Symbol: Daten
   Definitions
      At line 27 in file Assembler_Startup.s
   Uses
      None
Comment: Daten unused
Datenanfang 00000000

Symbol: Datenanfang
   Definitions
      At line 28 in file Assembler_Startup.s
   Uses
      At line 31 in file Assembler_Startup.s
      At line 32 in file Assembler_Startup.s

Datenende 00000400

Symbol: Datenende
   Definitions
      At line 33 in file Assembler_Startup.s
   Uses
      None
Comment: Datenende unused
Top_Stack 00000400

Symbol: Top_Stack
   Definitions
      At line 32 in file Assembler_Startup.s
   Uses
      At line 33 in file Assembler_Startup.s
      At line 48 in file Assembler_Startup.s

X 00000000

Symbol: X
   Definitions
      At line 31 in file Assembler_Startup.s
   Uses
      At line 49 in file Assembler_Startup.s
Comment: X used once
5 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

AtoI 00000018

Symbol: AtoI
   Definitions
      At line 74 in file Assembler_Startup.s
   Uses
      At line 174 in file Assembler_Startup.s
Comment: AtoI used once
AtoI_End 0000005C

Symbol: AtoI_End
   Definitions
      At line 101 in file Assembler_Startup.s
   Uses
      At line 90 in file Assembler_Startup.s
Comment: AtoI_End used once
AtoI_Loop 0000003C

Symbol: AtoI_Loop
   Definitions
      At line 87 in file Assembler_Startup.s
   Uses
      At line 99 in file Assembler_Startup.s
Comment: AtoI_Loop used once
Berechnung 000000DC

Symbol: Berechnung
   Definitions
      At line 171 in file Assembler_Startup.s
   Uses
      At line 50 in file Assembler_Startup.s
Comment: Berechnung used once
Formel 00000070

Symbol: Formel
   Definitions
      At line 112 in file Assembler_Startup.s
   Uses
      At line 175 in file Assembler_Startup.s
Comment: Formel used once
Programm 00000000

Symbol: Programm
   Definitions
      At line 39 in file Assembler_Startup.s
   Uses
      None
Comment: Programm unused
Reset_Handler 00000000

Symbol: Reset_Handler
   Definitions
      At line 41 in file Assembler_Startup.s
   Uses
      None
Comment: Reset_Handler unused
String 00000004

Symbol: String



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 43 in file Assembler_Startup.s
   Uses
      None
Comment: String unused
endlos 00000014

Symbol: endlos
   Definitions
      At line 66 in file Assembler_Startup.s
   Uses
      At line 66 in file Assembler_Startup.s
Comment: endlos used once
uItoBCD 00000090

Symbol: uItoBCD
   Definitions
      At line 134 in file Assembler_Startup.s
   Uses
      At line 176 in file Assembler_Startup.s
Comment: uItoBCD used once
uItoBCD_Done 000000D0

Symbol: uItoBCD_Done
   Definitions
      At line 164 in file Assembler_Startup.s
   Uses
      At line 143 in file Assembler_Startup.s
Comment: uItoBCD_Done used once
uItoBCD_Loop 000000A4

Symbol: uItoBCD_Loop
   Definitions
      At line 141 in file Assembler_Startup.s
   Uses
      At line 162 in file Assembler_Startup.s
Comment: uItoBCD_Loop used once
12 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

CHAR_0 00000030

Symbol: CHAR_0
   Definitions
      At line 188 in file Assembler_Startup.s
   Uses
      At line 92 in file Assembler_Startup.s
Comment: CHAR_0 used once
DIV_10 CCCCCCCD

Symbol: DIV_10
   Definitions
      At line 187 in file Assembler_Startup.s
   Uses
      At line 138 in file Assembler_Startup.s
Comment: DIV_10 used once
DIV_9 38E38E39

Symbol: DIV_9
   Definitions
      At line 186 in file Assembler_Startup.s
   Uses
      At line 114 in file Assembler_Startup.s
Comment: DIV_9 used once
RAM_Size 00000400

Symbol: RAM_Size
   Definitions
      At line 189 in file Assembler_Startup.s
   Uses
      At line 32 in file Assembler_Startup.s
Comment: RAM_Size used once
4 symbols
354 symbols in table
