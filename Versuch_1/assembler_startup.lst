


ARM Macro Assembler    Page 1 


    1 00000000         ;*******************************************************
                       *************
    2 00000000         ;* htw saar - Fakultaet fuer Ingenieurwissenschaften    
                       *
    3 00000000         ;* Labor fuer Eingebettete Systeme         *
    4 00000000         ;* Mikroprozessortechnik           *
    5 00000000         ;*******************************************************
                       *************
    6 00000000         ;* Assembler_Startup.S:            *
    7 00000000         ;* Programmrumpf fuer Assembler-Programme mit dem Keil  
                         *
    8 00000000         ;* Entwicklungsprogramm uVision fuer ARM-Mikrocontroller
                          *
    9 00000000         ;*******************************************************
                       *************
   10 00000000         ;* Aufgabe-Nr.:          *  Verusch 1                 *
   11 00000000         ;*                 *             *
   12 00000000         ;*******************************************************
                       *************
   13 00000000         ;* Gruppen-Nr.:    * 1. Gruppe am Freitag ab 3. Stunde *
                       
   14 00000000         ;*                 *          *
   15 00000000         ;*******************************************************
                       *************
   16 00000000         ;* Name / Matrikel-Nr.:  * Hanan Ahmed Ashir, 5012967   
                       *
   17 00000000         ;*       * Erwin Holzhauser, 5013983    *
   18 00000000         ;*       *          *
   19 00000000         ;*******************************************************
                       *************
   20 00000000         ;* Abgabedatum:          *  19.12.2025                *
   21 00000000         ;*       *          *
   22 00000000         ;*******************************************************
                       *************
   23 00000000         
   24 00000000         ;*******************************************************
                       *************
   25 00000000         ;* Daten-Bereich bzw. Daten-Speicher                 *
   26 00000000         ;*******************************************************
                       *************
   27 00000000                 AREA             Daten, DATA, READWRITE ;Ezeugun
                                                            g einer Speicherber
                                                            eich für Daten(RAM)
                                                                   
   28 00000000         Datenanfang
   29 00000000         
   30 00000000         
   31 00000000 00000000 
                       X       EQU              Datenanfang
   32 00000000 00000400 
                       Top_Stack
                               EQU              Datenanfang + RAM_Size
   33 00000000 00000400 
                       Datenende
                               EQU              Top_Stack
   34 00000000         
   35 00000000         ;*******************************************************
                       *************
   36 00000000         ;* Programm-Bereich bzw. Programm-Speicher       *



ARM Macro Assembler    Page 2 


   37 00000000         ;*******************************************************
                       *************
   38 00000000         
   39 00000000                 AREA             Programm, CODE, READONLY
   40 00000000                 ARM
   41 00000000 E321F010 
                       Reset_Handler
                               MSR              CPSR_c, #0x10 ; MSR=Move to Sta
                                                            tus Register. Der U
                                                            ser Mode wird in CP
                                                            SR geschrieben
   42 00000004         
   43 00000004         ;*******************************************************
                       *************
   44 00000004         ;* Hier das eigene (Haupt-)Programm einfuegen        *
   45 00000004         ;*******************************************************
                       *************
   46 00000004 E59FD0FC        LDR              SP, =Top_Stack ;Stack-pointer s
                                                            tartet hier
   47 00000008 E59F00FC        LDR              R0, =X      ; Load Register: Di
                                                            e Adresse von volls
                                                            tändiges 32 Bit Wor
                                                            t wird geladen
   48 0000000C EB000037        BL               Berechnung  ; 
   49 00000010         
   50 00000010         ;LDR R0, =String
   51 00000010         ;BL AtoI
   52 00000010         
   53 00000010         ;LDR R0, =X
   54 00000010         ;LDR R0, [R0]
   55 00000010         ;BL Formel
   56 00000010         
   57 00000010         ;LDR R0, =Number
   58 00000010         ;LDR R0, [R0]
   59 00000010         ;BL uItoBCD
   60 00000010         ;*******************************************************
                       *************
   61 00000010         ;* Ende des eigenen (Haupt-)Programms                   
                                   *
   62 00000010         ;*******************************************************
                       *************
   63 00000010         
   64 00000010 EAFFFFFE 
                       endlos  B                endlos      ;
   65 00000014         
   66 00000014         ;*******************************************************
                       *************
   67 00000014         ;* ab hier Unterprogramme                               
                                   *
   68 00000014         ;*******************************************************
                       *************
   69 00000014         
   70 00000014         
   71 00000014         ;------------------------Aufgabe 1----------------------
                       -------------
   72 00000014         AtoI
   73 00000014 E92D403E        STMFD            SP! ,{R1-R5, LR} ;Store Multipl
                                                            e Full Descending, 
                                                            !-> Writeback Suffi



ARM Macro Assembler    Page 3 


                                                            x: Nach dem Speiche
                                                            rn der Daten wird d
                                                            er SP aktualisiert
   74 00000018 E3A02000        MOV              R2, #0      ;Ergebnis wird hier
                                                             gespeichert
   75 0000001C E3A03000        MOV              R3, #0      ;Vorzeichen Flag: 0
                                                            =positive, 1=negati
                                                            ve
   76 00000020 E5D01000        LDRB             R1, [R0]    ;Load Register Byte
                                                            : Lädt nur ein einz
                                                            elnes Byte, geeigne
                                                            t für Strings 
   77 00000024         
   78 00000024 E351002B        CMP              R1, #0x2B   ;CMP macht intern e
                                                            ine Subtraktion: R1
                                                             = R1-0x2B und setz
                                                            t dann die Flags im
                                                             CSPR
   79 00000028 0A000002        BEQ              Skip_first_positive ; Branch if
                                                             equal: Wenn Z=1, d
                                                            ann Skip_First_posi
                                                            tive, ansonsten Zei
                                                            le 82. 
   80 0000002C         
   81 0000002C E351002D        CMP              R1, #0x2D   ; Auch R1=R1 -0x2D.
                                                             
   82 00000030 0A000002        BEQ              Set_Minus   ; Branch if equal: 
                                                            Wenn Z=1, dann Set_
                                                            Minus, ansonsten Lo
                                                            open
   83 00000034 EA000003        B                AtoI_Loop   ; Unconditional Bra
                                                            nch. Immer springen
                                                            .
   84 00000038         
   85 00000038         Skip_first_positive
   86 00000038 E2800001        ADD              R0, R0, #1  ; Falls erstes zeic
                                                            hen ein + war, über
                                                            springen und dann a
                                                            uf die nächste Ziff
                                                            er zeigen
   87 0000003C EA000001        B                AtoI_Loop   ; In die Main-loop 
                                                            gehen
   88 00000040         
   89 00000040         Set_Minus
   90 00000040 E3A03001        MOV              R3, #1      ; Falls - erkannt w
                                                            ird, setzte Flag au
                                                            f 1 
   91 00000044 E2800001        ADD              R0, R0, #1  ; Auf die nächste Z
                                                            eichen gehen und da
                                                            nn viola
   92 00000048         
   93 00000048         AtoI_Loop
   94 00000048 E5D01000        LDRB             R1, [R0]    ; Das nächste Zeoch
                                                            en wird jetzt in R1
                                                             geladen
   95 0000004C E3510000        CMP              R1, #0      ; Falls Zeichen 0, 
                                                            Z: Flag setzen
   96 00000050 0A000005        BEQ              AtoI_EndDigits 
                                                            ; Springe zu Ende



ARM Macro Assembler    Page 4 


   97 00000054         
   98 00000054 E2411030        SUB              R1, R1, #CHAR_0 ; Zeichen werde
                                                            n in numerischer We
                                                            rt konvertiert(z.B.
                                                             6(0x36) - 0(0x30) 
                                                            = 6) 
   99 00000058 E1A04182        MOV              R4, R2, LSL #3 ; Ersten teil de
                                                            r Multiplikation. D
                                                            ie zahl die bisher 
                                                            in R2 steht muss au
                                                            f Zehnerstelle rück
                                                            en, um platz für di
                                                            e nächste Zahl zu m
                                                            achen.
  100 0000005C         ; R4 = R2 * 8. 
  101 0000005C E0844082        ADD              R4, R4, R2, LSL#1 ; Add nimmt d
                                                            as Ergebnis von R4 
                                                            und addiert die R2*
                                                            2 dazu.
  102 00000060         ; R4  = Die bisherige Zahl(multipliziert mit 10)
  103 00000060 E0842001        ADD              R2, R4, R1  ; Jetzt müssen wir 
                                                            die neue Zahl bilde
                                                            n. (Alte Zahl in R4
                                                            (60) + neue Zahl in
                                                             R1(5) = "65___"
  104 00000064         
  105 00000064 E2800001        ADD              R0, R0, #1  ; Zeiger auf den nä
                                                            chste Ziffer setzen
                                                             und das ganze noch
                                                            mal wiederholen
  106 00000068 EAFFFFF6        B                AtoI_Loop   ; Solange loopen bi
                                                            s der Nullterminato
                                                            r erreicht ist.
  107 0000006C         AtoI_EndDigits
  108 0000006C E3530000        CMP              R3, #0      ; R3 = R3-0. Vorzei
                                                            chen prüfen. 
  109 00000070 0A000000        BEQ              AtoI_Positive ; Wenn der Flag a
                                                            m Anfang positive w
                                                            ar, direkt zum Erge
                                                            bnis 
  110 00000074 E2622000        RSB              R2, R2, #0  ; Wenn nicht, dann 
                                                            müssen wir Zweierko
                                                            mpliment bilden. Re
                                                            verse Subtraction(R
                                                            2=0-R2=-65535=0xFFF
                                                            F0001)
  111 00000078         
  112 00000078         AtoI_Positive
  113 00000078 E1A00002        MOV              R0, R2      ; Ergenis wird in R
                                                            0 wieder ausgegeben
                                                            
  114 0000007C E8BD403E        LDMFD            SP! ,{R1-R5, LR} ; Registern we
                                                            rden vom Stack wied
                                                            erhergestellt
  115 00000080 E12FFF1E        BX               LR          ; Branch and Exchan
                                                            ge: Erkennt Rückspr
                                                            ungadressen und hil
                                                            ft uns auf die Adre
                                                            ssen zu springen



ARM Macro Assembler    Page 5 


  116 00000084         
  117 00000084         
  118 00000084         ;-----------------Aufgabe 2 mit magic numbers-----------
                       ------------
  119 00000084         
  120 00000084         Formel
  121 00000084 E92D401E        STMFD            SP! ,{R1-R4, LR}
  122 00000088 E59F1080        LDR              R1, =DIV_9  ; R1 wird mit der M
                                                            agic Number geladen
                                                            (Siehe Skript Seite
                                                             96) 
  123 0000008C E0020090        MUL              R2, R0, R0  ; Quadrat wird bere
                                                            chnet und in R2 ges
                                                            peichert: R2 = (R0)
                                                            ^2
  124 00000090 E0843192        UMULL            R3, R4, R2, R1 ; UMULL: Unsigne
                                                            d Multiply long, we
                                                            il X^2*DIV_9 eine Z
                                                            ahl>32-Bit ist. 
  125 00000094         ; Ergebis wird eine 64-Bit Zahl, die in zwei Registern g
                       espeichert wird. (63-32)=R4, (31-0)=R3
  126 00000094 E1A030A4        MOV              R3, R4, LSR #1 ; Um die größe Z
                                                            ahl mit genauigkeit
                                                             in einem register 
                                                            zu schreiben machen
                                                             wir ein Right shif
                                                            t.(siehe "n" auf de
                                                            r Siete 96)
  127 00000098         ; Also (X^2/9) wird grob geschätzt und im Register R3 ge
                       speichert.
  128 00000098 E1A00103        MOV              R0, R3, LSL #2 ; Wir rechnen hi
                                                            er (X^2/9)*4. Also 
                                                            Link Shift um 2^2=4
                                                            .
  129 0000009C E8BD401E        LDMFD            SP!, {R1-R4, LR} ; Registern we
                                                            rden wieder vom Sta
                                                            ck entfernt und Erg
                                                            ebnis steht im R0
  130 000000A0 E12FFF1E        BX               LR          ; Wieder zu Rückspr
                                                            ungadressen springe
                                                            n
  131 000000A4         
  132 000000A4         ;------------------------Aufgabe 3 mit magic numbers----
                       -------------
  133 000000A4         
  134 000000A4         ; anhand dieses Formel (Pseudocode): while (dec)
  135 000000A4         ;    {
  136 000000A4         ;        result +=  (dec % 10) << shift;
  137 000000A4         ;        dec = dec / 10;
  138 000000A4         ;        shift += 4;
  139 000000A4         ;    }
  140 000000A4         ;    return result;
  141 000000A4         
  142 000000A4         uItoBCD
  143 000000A4 E92D41FE        STMFD            SP! ,{R1-R8, LR} ; Register R1 
                                                            bis R8 auf den Stac
                                                            k laden.
  144 000000A8 E3A01000        MOV              R1, #0      ; Ergebnis wird hie
                                                            r gespeichert



ARM Macro Assembler    Page 6 


  145 000000AC E3A02000        MOV              R2, #0      ; Shift kommmt hier
                                                            . (0,4,8,...)
  146 000000B0 E59F505C        LDR              R5, =DIV_10 ; R5 bekommt magisc
                                                            he Nummer für Divis
                                                            ion durch 10
  147 000000B4 E3A0600A        MOV              R6, #10     ; R6 bekommt die Ko
                                                            nstante Zahl 10 für
                                                             Modulo-Operation
  148 000000B8         
  149 000000B8         uItoBCD_Loop
  150 000000B8 E3500000        CMP              R0, #0      ; R0 = R0-0 und Fla
                                                            gs Setzen. Falls Er
                                                            gebnis 0, dann sind
                                                             wir schon fertig
  151 000000BC 0A000008        BEQ              uItoBCD_Done ; Springe zu Ende
  152 000000C0         
  153 000000C0         
  154 000000C0 E0873590        UMULL            R3, R7, R0, R5 ; Unsigned Integ
                                                            er, also UMULL darf
                                                             verwendet werden. 
                                                            
  155 000000C4         ; R0 wird mit magische Nummer multipliziert und Ergebnis
                        wird in R3 ind R7 gespeichert   
  156 000000C4 E1A031A7        MOV              R3, R7, LSR#3 ; Genauere Ergebi
                                                            s in 32 Bit, R7 mus
                                                            s noch 3 bits geshi
                                                            ftet werden(siehe "
                                                            n" Seite 96)
  157 000000C8         ; Für 123 berechnen wir: q = 123/10 = 12(kommt in R3)
  158 000000C8         
  159 000000C8 E0040693        MUL              R4, R3, R6  ; In R4 steht jetzt
                                                             = q * 10.  Dann is
                                                            t R4=12*10=120     
                                                                               
                                                                               
                                                                     ------ mul
                                                             lieber mit shift -
                                                            > schneller
  160 000000CC E0404004        SUB              R4, R0, R4  ; r = R0 - (q * 10)
                                                             , sprich modulo. (
                                                            123 -120) = 3. Also
                                                             letzte Dezimalziff
                                                            er steht in R4
  161 000000D0         
  162 000000D0 E1A08214        MOV              R8, R4, LSL R2 ; Nimmt den Inha
                                                            lt von n und schieb
                                                            t so viele Bits nac
                                                            h links, wie in R2 
                                                            steht              
                                                                        ------ 
                                                            kann man sich spare
                                                            n, diretk bei add s
                                                            hiften
  163 000000D4         ; Das Ergebnis landet dann in R8
  164 000000D4 E0811008        ADD              R1, R1, R8  ; R1 speichert das 
                                                            BCD Ergebnis, R8 wi
                                                            rd dort addiert.
  165 000000D8         
  166 000000D8         



ARM Macro Assembler    Page 7 


  167 000000D8 E1A00003        MOV              R0, R3      ; R3 enthält die Qu
                                                            otient, das wird in
                                                             R0 als Eingabe ges
                                                            chickt und die näch
                                                            ste Iteration begin
                                                            nt
  168 000000DC E2822004        ADD              R2, R2, #4  ; bei jeder iterati
                                                            on wird einmla mehr
                                                             um 4 geshiftet, da
                                                            mit die nächste Dez
                                                            imalzahl richtig po
                                                            sitioniert wird
  169 000000E0         
  170 000000E0 EAFFFFF4        B                uItoBCD_Loop ; Sprint zurück zu
                                                            m Anfang der Schlei
                                                            fe
  171 000000E4         
  172 000000E4         uItoBCD_Done
  173 000000E4 E1A00001        MOV              R0, R1      ; Fertige BCD Ergni
                                                            s wird in R0 gemove
                                                            d 
  174 000000E8 E8BD41FE        LDMFD            SP! ,{R1-R8, LR} ; Registern wi
                                                            eder freimachen
  175 000000EC E12FFF1E        BX               LR          ; Zur Rücksprungadr
                                                            esse springen
  176 000000F0         
  177 000000F0         ;------------------------Aufgabe 4----------------------
                       -------------
  178 000000F0         
  179 000000F0         Berechnung
  180 000000F0 E92D4000        STMFD            SP!, {LR}   ; Rücksprungadresse
                                                             sichern
  181 000000F4         
  182 000000F4 EBFFFFC6        BL               AtoI        ; R0 = X (signed In
                                                            teger)
  183 000000F8 EBFFFFE1        BL               Formel      ; R0 = Y = 4*X^2/9
  184 000000FC EBFFFFE8        BL               uItoBCD     ; R0 = Y als BCD
  185 00000100         
  186 00000100 E8BD4000        LDMFD            SP! ,{LR}
  187 00000104 E12FFF1E        BX               LR
  188 00000108         
  189 00000108         
  190 00000108         ;*******************************************************
                       *************
  191 00000108         ;* Konstanten im CODE-Bereich                           
                                   *
  192 00000108         ;*******************************************************
                       *************
  193 00000108         
  194 00000108         
  195 00000108 38E38E39 
                       DIV_9   EQU              0x38E38E39  ; mit n=1
  196 00000108 CCCCCCCD 
                       DIV_10  EQU              0xCCCCCCCD  ; mit n=3
  197 00000108 00000030 
                       CHAR_0  EQU              0x30
  198 00000108 00000400 
                       RAM_Size
                               EQU              0x400       ; 4*16^2=1024 bytes



ARM Macro Assembler    Page 8 


                                                            
  199 00000108         
  200 00000108         ;X DCD 100
  201 00000108         ;Number DCD 3043
  202 00000108         
  203 00000108         
  204 00000108         ;*******************************************************
                       *************
  205 00000108         ;* Ende der Programm-Quelle                             
                                   *
  206 00000108         ;*******************************************************
                       *************
  207 00000108                 END
              00000000 
              00000000 
              38E38E39 
              CCCCCCCD 
Command Line: --debug --xref --depend=.\assembler_startup.d -o.\assembler_start
up.o -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Phili
ps --predefine="__EVAL SETA 1" --list=.\assembler_startup.lst Assembler_Startup
.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

Daten 00000000

Symbol: Daten
   Definitions
      At line 27 in file Assembler_Startup.s
   Uses
      None
Comment: Daten unused
Datenanfang 00000000

Symbol: Datenanfang
   Definitions
      At line 28 in file Assembler_Startup.s
   Uses
      At line 31 in file Assembler_Startup.s
      At line 32 in file Assembler_Startup.s

Datenende 00000400

Symbol: Datenende
   Definitions
      At line 33 in file Assembler_Startup.s
   Uses
      None
Comment: Datenende unused
Top_Stack 00000400

Symbol: Top_Stack
   Definitions
      At line 32 in file Assembler_Startup.s
   Uses
      At line 33 in file Assembler_Startup.s
      At line 46 in file Assembler_Startup.s

X 00000000

Symbol: X
   Definitions
      At line 31 in file Assembler_Startup.s
   Uses
      At line 47 in file Assembler_Startup.s
Comment: X used once
5 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

AtoI 00000014

Symbol: AtoI
   Definitions
      At line 72 in file Assembler_Startup.s
   Uses
      At line 182 in file Assembler_Startup.s
Comment: AtoI used once
AtoI_EndDigits 0000006C

Symbol: AtoI_EndDigits
   Definitions
      At line 107 in file Assembler_Startup.s
   Uses
      At line 96 in file Assembler_Startup.s
Comment: AtoI_EndDigits used once
AtoI_Loop 00000048

Symbol: AtoI_Loop
   Definitions
      At line 93 in file Assembler_Startup.s
   Uses
      At line 83 in file Assembler_Startup.s
      At line 87 in file Assembler_Startup.s
      At line 106 in file Assembler_Startup.s

AtoI_Positive 00000078

Symbol: AtoI_Positive
   Definitions
      At line 112 in file Assembler_Startup.s
   Uses
      At line 109 in file Assembler_Startup.s
Comment: AtoI_Positive used once
Berechnung 000000F0

Symbol: Berechnung
   Definitions
      At line 179 in file Assembler_Startup.s
   Uses
      At line 48 in file Assembler_Startup.s
Comment: Berechnung used once
Formel 00000084

Symbol: Formel
   Definitions
      At line 120 in file Assembler_Startup.s
   Uses
      At line 183 in file Assembler_Startup.s
Comment: Formel used once
Programm 00000000

Symbol: Programm
   Definitions
      At line 39 in file Assembler_Startup.s
   Uses
      None
Comment: Programm unused
Reset_Handler 00000000



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols


Symbol: Reset_Handler
   Definitions
      At line 41 in file Assembler_Startup.s
   Uses
      None
Comment: Reset_Handler unused
Set_Minus 00000040

Symbol: Set_Minus
   Definitions
      At line 89 in file Assembler_Startup.s
   Uses
      At line 82 in file Assembler_Startup.s
Comment: Set_Minus used once
Skip_first_positive 00000038

Symbol: Skip_first_positive
   Definitions
      At line 85 in file Assembler_Startup.s
   Uses
      At line 79 in file Assembler_Startup.s
Comment: Skip_first_positive used once
endlos 00000010

Symbol: endlos
   Definitions
      At line 64 in file Assembler_Startup.s
   Uses
      At line 64 in file Assembler_Startup.s
Comment: endlos used once
uItoBCD 000000A4

Symbol: uItoBCD
   Definitions
      At line 142 in file Assembler_Startup.s
   Uses
      At line 184 in file Assembler_Startup.s
Comment: uItoBCD used once
uItoBCD_Done 000000E4

Symbol: uItoBCD_Done
   Definitions
      At line 172 in file Assembler_Startup.s
   Uses
      At line 151 in file Assembler_Startup.s
Comment: uItoBCD_Done used once
uItoBCD_Loop 000000B8

Symbol: uItoBCD_Loop
   Definitions
      At line 149 in file Assembler_Startup.s
   Uses
      At line 170 in file Assembler_Startup.s
Comment: uItoBCD_Loop used once
14 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

CHAR_0 00000030

Symbol: CHAR_0
   Definitions
      At line 197 in file Assembler_Startup.s
   Uses
      At line 98 in file Assembler_Startup.s
Comment: CHAR_0 used once
DIV_10 CCCCCCCD

Symbol: DIV_10
   Definitions
      At line 196 in file Assembler_Startup.s
   Uses
      At line 146 in file Assembler_Startup.s
Comment: DIV_10 used once
DIV_9 38E38E39

Symbol: DIV_9
   Definitions
      At line 195 in file Assembler_Startup.s
   Uses
      At line 122 in file Assembler_Startup.s
Comment: DIV_9 used once
RAM_Size 00000400

Symbol: RAM_Size
   Definitions
      At line 198 in file Assembler_Startup.s
   Uses
      At line 32 in file Assembler_Startup.s
Comment: RAM_Size used once
4 symbols
356 symbols in table
